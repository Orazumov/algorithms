# Урок 6.

# Управление памятью.

# Идея кучи заключается в том, что когда мы пишем а = 5
# в куче выделяется место под 5, объект целого типа.
# Затем мы создали список - где-то под него снова выделилось
# место. Затем, когда мы поработали, место освобождается и
# может переиспользоваться.

# В питоне программист не участвует в этом процессе.
# Внутри интерпретатора есть сборщик мусора, он сам очищает
# свободное место.

# В реальном видев Питоне переменная - это не коробка, в которую
# помещают цифру, а объект 5 - это место в памяти:
# там есть счетчик ссылок, указатель типа и само число 5.
# А переменная 5 - это по сути просто ссылка на место в
# памяти (как стикер на ящик с числом).
# Когда мы пишем в = 5, то и стикер в мы клеем на тот же
# ящик.

# Каждый раз когда ссылаемся на объект - делаем +1 к счетчику
# ссылок. Когда счетчик = 0, то объект не используется.

# Счетчик можно обнулить программно:

del a

# это разрым связи между ссылкой и объектом.

# Экскурс в список list:

# Создаем список:

lst = [1]

# создается объект список и объект единица (int).

# список понимает, что у него в 0 ячейке лежит адрес - ссылка
# на другой объект = 1.
# сумарно зарезервировано 4 ячейки (байта).

# Легко можем найти адрес нужной ячейки:

# N + S*i   S - размер ячейки, i - количество ячеек
# N - текущая ячейка.

# По сути у нас в массиве хранятся только ссылки на объекты.

lst.extend([2, 3, 4])

# в памяти создаются отдельные объекты 2, 3 и 4.
# в списке появляются ссылки на эти объекты.

# т.е. список занял какое-то место + объекты заняли какое-то
# место в памяти.

lst.insert(1, 5)

# список понимает, что у него все занято, он обращается в
# кучу и резервирует себе еще 4 ячейки.
# Потом сдвиг все ячеек, затем помещаем в нужную ячейку ссылку.

# Что если после массива у нас хранится другой объект и этот не расширить?
# Питон найдет другое место в памяти и перенесет туда весь список, а текущий - удалит.

spam = lst.pop()

# список всегда знает сколько у него ячеек, последняя цчейка быстро переносится в переменную spam.
# адрес в списке даже не удаляется, зачем тратить ресурсы? просто зарактеристика списка = длина - 1.

# Часть свободных ячеек возвр. обратно в кучу.

lst.remove(5)   # работает еще медленнее чем инсерт.

# все ячейки, которые были ниже удалемой ссылки, мы копируем выше к началу.
# Сначала мы идем по объектам, сравниваем их с нужным, а потом еще и сдвигаем все. Пустых ячеек быть не может!
# Очень медленно.
# О(n)

# Как происходит увеличение и уменьшение списка?

allocated = 0

for new_size in range(1000):
    if allocated < new_size:
        new_allocated = (new_size >> 3) + (3 if new_size < 9 else 6) # сдвиг на 3 байта вправо.
        allocated = new_size + new_allocated
    print(f'P{new_size=}\t{allocated}')
# видно как работает расширение.
# идея - чем больше ячеек заполнены, тем больше у нас ячеек в резерве.

lst_new = [None] * 1120

# сразу выделено место под список с 1120 None. Место выделяется сразу, вроде быстрее,
# но теперь нужно исп. не append.

my_index = 0
lst_new[my_index] = 'fsfer'

# т.е. самому нужно следить за тем в какую ячейку заполнять.
# Адрес None хранится в единственном экземпляре, поэтому хранится не 1120 None, а один
# и ссылки на него.

# в консоли Питона:

a = 100
b = 123 - 23

id(a)
id(b)

# Это одни и те же объекты.

a == b
# True
a is b
# True

c = 1000
d = 1100 - 100

# id теперь разные.

# числа от -4 до + 255 хранятся заранее с большим счетчиком ссылок.
# если объекты выходят за диопазон, то они создаются заново, поэтому получаются разные объекты в памяти.

a = 'Hello world!'
#  что можем узнать про объект?

print(id(a))
# видим адрес объекта.

import sys
print(sys.getsizeof(a))

# видим сколько байт занимает в ОП.

print(sys.getrefcount(a))
# видим сколько ссылок + пара ссылок от самого метода.

# Можем добавлять ссылки и смотреть как увеличилось.
# del - удаляем ссылки.

# определим ф. для того чтобы посмотреть сколько занимает места.

d = 43
print(sys.getsizeof(d))
# 14 байт
d = 4342424
print(sys.getsizeof(d))
# 16 байт
# автоматически подгоняется размер памяти.

e = 42.0
print(sys.getsizeof(e))

# 16 байт

e = 443432.04543353534
print(sys.getsizeof(e))
# все равно 16!

# т.к. у вещ. чисел есть ограничения по точности, часть чисел
# округляется.

def show(object):

    print(f'type = {type(object)}, size={sys.getsizeof(object)}, object={object}')

show(d)

# все норм, инфа выдается.

lst = [i for i in range(10)]

# мы видим не все, т.к. числа, которые хранит список, тоже занимают место в памяти.

def show(object):

    print(f'type = {type(object)}, size={sys.getsizeof(object)}, object={object}')
    if hasattr(object, '__iter__'):   # если объект итерируемый
        if hasattr(object, '__items__'):  # если есть ключ и значение
            for key, value in object.items():
                show(key)
                show(value)

        elif not isinstance(object, str):   # если строка...
            for item in object:
                show(item)

show(lst)     # - видим сколько памято съели на список и все объекты.

# также можно смотреть словари, кортежи, множества.

a = 42
print(id(a))
print(sys.getsizeof(a))

# это мы знаем про объект - адрес и размер объекта.

import ctypes

# смотрим содержимое памяти:

print(ctypes.string_at(id(a), sys.getsizeof(a)))
# ф. принимает на вход: адрес в оперативке и сколько байт читаем.
# прочитали объект: счетчик ссылок, доп. инф, сама пятерка..

print(struct.unpack('HHLHHh', ctypes.string_at(id(a), sys.getsizeof(a)))

# в начале идет шаблон, потом сам объект.
# прочитаем объект, шаблон показывает в каком виде представлшять объект.
# шаблоны читаем на сайте python.org

# указатель типа - ссылается на тип объекта в памяти.

print(id(int)) # тоже самое.


